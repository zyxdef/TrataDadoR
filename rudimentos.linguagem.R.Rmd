---
title: "Rudimentos da Linguagem R"
author: "Marcelo Ventura Freire (EACH/USP)"
output: ioslides_presentation
---

```{r setup, include=FALSE, eval=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

## O que veremos nesse curso

1. Tipos e estruturas de dados em R 
    1. Tipos de dados
    2. Estruturas de dados
    3. Atributos
    4. “Não-dados”
2. Programação em R
    1. Operador de atribuição
    2. Operadores de extração (*subscripting*) 
    3. Instruções de repetições
    4. Instruções de execução condicional
    5. Funções e operações 

# Tipos e Estruturas de Dados em R 
## Tipos de Dados
1. quantitativo (`numeric()`), 
2. textual (`character()`), 
3. lógico (`logical()`), 
4. categórico (`factor()` e `ordered()`)
5. outros

## Tipos de Dados
### Quantitativo

O R consegue lidar números

- inteiros (*integer*)
    - `1L`, `10L`, `-5L`
- reais (*double*)
    - `1`, `10`, `10.0`, `-10.5`
- complexos (*complex*)
    - `1 + 0i`, `2 + 3i`, `1i`

Valores numéricos são *double* por padrão, a menos que explicitado outro tipo.

## Tipos de Dados
###Textual

O R consegue lidar com informações textuais

```{r}
'Isto é um texto'
"Isto também"
paste("Nós somos", "dois textos.")
```

## Tipos de Dados
###Lógico
O R consegue lidar com valores lógicos: 

- verdadeiro (`TRUE` ou `T`) 
- falso (`FALSE` ou `F`)

```{r}
2 < 3
x <- (2 < 3)
x
```

## Tipos de Dados
### Categórico 

O R consegue lidar com dados qualitativos 

- nominais (através da função `factor()`)
- ordinais (através da função `ordered()`)

Dados categóricos são mais do que apenas textos em R.

Eles têm metainformação, que os dados textuais não têm.

        Fatores = Dados + Metadados

## Tipos de Dados
### Categórico 

```{r}
c("criança", "adulto", "idoso")     # só texto
factor(c("criança", "adulto", "idoso"))     # fator
```

## Tipos de Dados
### Categórico 

```{r}
dados <- c(3, 2, 1, 3, 2)
categs <- c("criança", "adulto", "idoso")
factor(dados, levels = 1:3, labels = categs)
ordered(dados, levels = 1:3, labels = categs)
```

Note as categorias

## Tipos de Dados
### Categórico 

```{r}
dados <- c(3, 2, 1, 3, 2)
categs <- c("criança", "adulto", "idoso")
factor(dados, levels = 1:3, labels = categs, ordered = T)
ordered(dados, levels = 1:3, labels = categs)
```
A mesma coisa

## Tipos de Dados
### Categórico 

```{r}
ordered(c("criança", "adulto", "idoso")) # Errado! Note as categorias
categs <- c("criança", "adulto", "idoso")
ordered(c("criança", "adulto", "idoso"), levels = categs)  # Ok
```

## Estruturas de Dados
1. vetorial (`c()`, `vector()`), 
2. lista/“dicionário” (`list()`), 
3. matricial (`matrix()` e `array()`),
4. conjunto de dados (`data.frame()`)

## Estruturas de Dados
### Vetores 

Por padrão, os dados no R são vetores 

```{r}
2 + 2
```

Esse `[1]` antes do resultado 
é a posição (um) do valor `4` 
dentro do vetor de comprimento unitário 
que é o resultado da operação acima.

## Estruturas de Dados
### Vetores 

```{r}
c(1, 2, 3, 4)
1:4
```

## Estruturas de Dados
### Vetores 

```{r}
1:10
1:40
```

O `[24]` na segunda linha do resultado de `1:40` 
é um lembrete que o valor `24` ocupa a 24^a^ posição do resultado da operação.

## Estruturas de Dados
### Vetores 

A função `c()` gera vetores e também junta e "achata" múltiplos vetores em um único vetor.

```{r}
c(1, 2, 3, 4); c(5, 6, 7, 8)
c(c(1, 2, 3, 4), c(5, 6, 7, 8))
```

## Estruturas de Dados
### Vetores 

Os dados de um vetor **têm** que ser do mesmo tipo.

Se não forem, o R converte todos para um mesmo tipo 
que os comporte através de *regras de coerção*.

```{r}
c(1, 2, 3, 4)
c(1, 2, 3, 4, "A")
```

## Estruturas de Dados
### Vetores 

Os dados de um vetor **têm** que ser do mesmo tipo.

Se não forem, o R converte todos para um mesmo tipo 
que os comporte através de *regras de coerção*.

```{r}
typeof(c(1L, 2L, 3L, 4L)); typeof(c(1, 2L, 3L, 4L))
```

## Estruturas de Dados
### Vetores 

Os dados de um vetor **têm** que ser do mesmo tipo.

Se não forem, o R converte todos para um mesmo tipo 
que os comporte através de *regras de coerção*.

```{r}
c(1L, 2, 3 + 0i)
c(1L, 2, 3 + 0i, "A")
```



## Estruturas de Dados
### Lista

Informalmente, as listas podem ser pensadas como vetores 
que comportam dados de diferentes tipos 
sem que eles sejam forçados a terem o mesmo tipo em comum.

```{r}
list(1,2)
```

## Estruturas de Dados
### Lista

```{r}
list(1, 2)
```

Esse `[[2]]` indica que a 2^a^ posição da lista é ocupada por um vetor.

O `[1]` seguinte indica que a 1^a^ posição desse vetor é o valor `2` apresentado.

## Estruturas de Dados
### Lista

É possível aninhar listas dentro de listas.

```{r}
list(list(1, 2), c(1, 2))
```

## Estruturas de Dados
### Lista

```{r}
list(list(list(1, 2), 3))
```

## Estruturas de Dados
### Lista

Mas dá para "achatar" a lista em um vetor
```{r}
unlist(list(list(list(1, 2), 3)))
```

## Estruturas de Dados
### Matrizes e *Arrays*

Matrizes podem ser pensadas como vetores com duas "direções" e 
*arrays* como vetores com várias "direções".

```{r}
matrix(c(1, 2, 3, 4), nrow = 2)
matrix(1:8, nrow = 2)
```

## Estruturas de Dados
### Matrizes e *Arrays*

Matrizes podem ser pensadas como vetores com duas "direções" e 
*arrays* como vetores com várias "direções".

```{r}
array(1:12, dim = c(2, 3, 2))
```

## Estruturas de Dados
### Matrizes e *Arrays*

Na verdade, vetores são *arrays* unidimensionais 
e matrizes são *arrays* bidimensionais.

```{r}
array(1:4, dim = c(4))
array(1:4, dim = c(2,2))
```

## Estruturas de Dados
### Matrizes e *Arrays*

Por motivos históricos, as matrizes são preenchidas no R por colunas 
ao invés de ser por linhas, mas isso pode ser mudado.

```{r}
matrix(1:8, nrow = 2, byrow = T)
```

## Estruturas de Dados
### Matrizes e *Arrays*

Assim, como os vetores, 
os valores de uma matriz e *array* têm que ser do mesmo tipo
ou então eles são forçados por regras de coreção.

```{r}
array(c(1, 2, 3, "A"), dim = c(2,2))
```

## Estruturas de Dados
### Conjunto de Dados (*Data Frames*)

## Atributos
1. `names()`, 
2. `levels()` e `nlevels()`
3. `dim()` e `dimnames()` 
4. `rownames()` e `colnames()`
5. `ncols()` e `nrows()`

## Os “Não-Dados” do R
1. Dado faltante (*missing*): `NA` -- *Not Available*
2. Dado não numérico: `NaN` -- *Not a Number*
3. Valor Infinito: `Inf`
4. Ausência de valor: `NULL`

## Os “Não-Dados” do R
### Dado Faltante
```{r}
idades <- c(18, 28, NA, 32)
idades
```

## Os “Não-Dados” do R
### Dado Não Numérico
```{r}
log(-2)
```

## Os “Não-Dados” do R
###  Valor Infinito
```{r}
log(0)
```

## Os “Não-Dados” do R
###  Ausência de Valor
```{r}
c()
```

# Programação em R
## Programação em R
1. Operador de atribuição
2. Operadores de extração (*subscripting*) 
3. Instruções de repetição
4. Instruções de execução condicional
5. Operações matemáticas
5. Operações de comparação
5. Operações lógicas
5. Funções

## Operador de Atribuição

O operador `<-`

## Operadores de Extração
1. Os operadores `[]`, `[[]]` e `$`
2. Indexando nas linhas e colunas
3. Indexando com vetores numéricos positivos e negativos 
4. Indexando com vetores lógicos 
5. Indexando com vetores textuais
6. A opção `drop = F` do operador `[]`

***

AQUI!!!  Um slide para cada um desses

## Instruções de Repetição (*Loop*)
1. A instrução `for`
    1. `1:N`, 
    2. `names()`
    3. `seq()`, `seq_len()` e `seq_along()`
2. *As instruções `while`, `repeat`, `break` e `next`*

## Instruções de Execução Condicional
1. As instruções `if` e `else`
2. *A função `switch()`*

## Funções e Operações, Operações e Funções 
1. Operações matemáticas
2. Operações de comparação
3. Operações lógicas
4. Executando funções existentes
5. Criando as suas próprias funções

## Programação em R
### Operações de Comparação

## Programação em R
### Operações Lógicas

## Programação em R
### Executando Funções Existentes

## Programação em R
### Criando as suas Próprias Funções


